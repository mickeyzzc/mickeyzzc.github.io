<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.131.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.png><link rel=icon type=image/x-icon href=/imgs/icons/favicon.png><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/favicon.png><meta itemprop=name content="闲聊一下CPU时序和现代操作系统二三事"><meta itemprop=description content="What is rational is real; and what is real is rational."><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/imgs/icons/custom.png"><meta itemprop=keywords content="Linux"><meta property="og:type" content="article"><meta property="og:title" content="闲聊一下CPU时序和现代操作系统二三事"><meta property="og:description" content="What is rational is real; and what is real is rational."><meta property="og:image" content="/imgs/icons/custom.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/posts/opentelemetry/talk-about-cpu-timer/"><meta property="og:site_name" content="蓝宝石的傻话"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="蓝宝石的傻话"><meta property="article:published_time" content="2023-01-20 00:00:00 +0000 UTC"><meta property="article:modified_time" content="2023-01-20 00:00:00 +0000 UTC"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.374a99719ba5f425af97e9e4d4b002d4efa1a29ac3be3b0cb855d613bc1fbddf.css><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"talk-about-cpu-timer","permalink":"/posts/opentelemetry/talk-about-cpu-timer/","title":"闲聊一下CPU时序和现代操作系统二三事","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>闲聊一下CPU时序和现代操作系统二三事 - 蓝宝石的傻话</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>蓝宝石的傻话</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>MickeyBee's BLOG</p><img class=custom-logo-image src=/imgs/icons/custom.png alt=蓝宝石的傻话></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>14</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#时分系统和linux>时分系统和Linux</a><ul><li><a href=#时间片>时间片:</a></li><li><a href=#上下文切换>上下文切换:</a></li><li><a href=#进程调度>进程调度:</a></li><li><a href=#中断机制>中断机制:</a></li><li><a href=#时钟事件>时钟事件:</a></li></ul></li><li><a href=#聊一下linux的时序>聊一下Linux的时序</a><ul><li><a href=#some-words>Some Words</a><ul><li><a href=#jiffies>Jiffies</a></li><li><a href=#cpu时间片>CPU时间片</a></li><li><a href=#cpu队列>CPU队列</a></li></ul></li><li><a href=#so>SO？</a></li><li><a href=#那时钟中断频率和时间片有什么关系和区别>那时钟中断频率和时间片有什么关系和区别？</a></li><li><a href=#补习了这些概念有啥用>补习了这些概念有啥用？</a></li></ul></li><li><a href=#排队论>排队论</a></li><li><a href=#提外话也聊一下>提外话也聊一下</a><ul><li><a href=#观测cpu截流>观测CPU截流</a><ul><li><a href=#cpu截流通常用于以下场景>CPU截流通常用于以下场景:</a></li><li><a href=#cpu截流通常有两种主要方式>CPU截流通常有两种主要方式:</a></li><li><a href=#cpu截流的计算逻辑主要涉及两个方面>CPU截流的计算逻辑主要涉及两个方面:</a></li></ul></li></ul></li><li><a href=#prometheus和cpu截流的小故事>Prometheus和CPU截流的小故事：</a><ul><li><a href=#一般主机场景>一般主机场景</a></li><li><a href=#kubernetes集群>Kubernetes集群</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=蓝宝石的傻话 src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpeg><p class=site-author-name itemprop=name>蓝宝石的傻话</p><div class=site-description itemprop=description>What is rational is real; and what is real is rational.</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>14</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>10</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>13</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/mickeyzzc title="Github → https://github.com/mickeyzzc" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=https://gitee.com/mickeybee title="Gitee → https://gitee.com/mickeybee" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Gitee
</a></span><span class=links-of-social-item><a href=mailto:mickey_zzc@163.com title="E-Mail → mailto:mickey_zzc@163.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://blog.51cto.com/mickeyzzc title=https://blog.51cto.com/mickeyzzc target=_blank>我的51cto博客</a></li><li class=links-of-blogroll-item><a href=https://deepflow.io/ title=https://deepflow.io/ target=_blank>DeepFlow</a></li><li class=links-of-blogroll-item><a href=https://blog.csdn.net/mickey_zzc title=https://blog.csdn.net/mickey_zzc target=_blank>CSDN博客</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2016-08-11T00:00:00+00:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=31194></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=68></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2023-11-25T00:00:00+00:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-gtranslate class=button title=多语言翻译><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/mickeyzzc rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg>
</a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/posts/opentelemetry/talk-about-cpu-timer/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpeg"><meta itemprop=name content="蓝宝石的傻话"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="蓝宝石的傻话"><meta itemprop=description content="What is rational is real; and what is real is rational."></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="闲聊一下CPU时序和现代操作系统二三事"><meta itemprop=description content="时分系统和Linux 首先我们补习一下时分系统，时分系统是一个非常重要的操作系统概念,它最大限度地提高了运算机的利用率,是实现多道程序并发执行"></span><header class=post-header><h1 class=post-title itemprop="name headline">闲聊一下CPU时序和现代操作系统二三事
<a href=https://github.com/mickeyzzc/mickeyzzcblog/tree/main/content/posts/opentelemetry/talk-about-cpu-timer.md rel="noopener external nofollow noreferrer" target=_blank class="exturl post-edit-link" title=编辑><i class="fa fa-pen-nib"></i></a></h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-01-20 00:00:00 +0000 UTC" itemprop="dateCreated datePublished" datetime="2023-01-20 00:00:00 +0000 UTC">2023-01-20
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/cpu itemprop=url rel=index><span itemprop=name>Linux/CPU</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>7426</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>15分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=busuanzi_value_page_pv data-path=/posts/opentelemetry/talk-about-cpu-timer/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h2 id=时分系统和linux>时分系统和Linux
<a class=header-anchor href=#%e6%97%b6%e5%88%86%e7%b3%bb%e7%bb%9f%e5%92%8clinux></a></h2><p>首先我们补习一下时分系统，时分系统是一个非常重要的操作系统概念,它最大限度地提高了运算机的利用率,是实现多道程序并发执行的重要手段。
我们日常工作用到的Linux系统 内核也采用了时分系统的思想,主要体现在以下几个方面:</p><h3 id=时间片>时间片:
<a class=header-anchor href=#%e6%97%b6%e9%97%b4%e7%89%87></a></h3><p>Linux 使用时间片机制对 CPU 进行时间分割,每个进程只能执行一个时间片的时间,然后交出 CPU 给其他进程运行。这实现了 CPU 时间的共享与公平分配。</p><h3 id=上下文切换>上下文切换:
<a class=header-anchor href=#%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2></a></h3><p>当时间片用完或进程主动放弃 CPU 时,会进行上下文切换,保存当前进程上下文并恢复下一个进程上下文。这使得 CPU 可以高效地在不同进程间切换。</p><h3 id=进程调度>进程调度:
<a class=header-anchor href=#%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6></a></h3><p>Linux 使用 CFS 调度器根据每个进程的时间片选择最适合运行的进程,这是时分系统思想的体现。不同的调度策略可以实现不同的时分效果。</p><h3 id=中断机制>中断机制:
<a class=header-anchor href=#%e4%b8%ad%e6%96%ad%e6%9c%ba%e5%88%b6></a></h3><p>Linux 使用中断机制实现对时间的管理与调度。时钟中断可以在时间片用完时通知内核进行上下文切换与调度。这为时分系统提供了动力基础。</p><h3 id=时钟事件>时钟事件:
<a class=header-anchor href=#%e6%97%b6%e9%92%9f%e4%ba%8b%e4%bb%b6></a></h3><p>Linux 基于时分系统管理各种时间事件,如定时器、睡眠唤醒等。这需要内核根据时钟中断来进行管理与调度。</p><blockquote><p>除此之外,时分系统的思想在 Linux 中还体现在:</p><ol><li>多道程序设计
Linux 支持多道程序并发运行,这也依赖于时分系统实现的 CPU 时间共享机制。</li><li>实时性
通过设置实时调度策略和对中断处理的优化,Linux 可以提供较好的实时响应性能。这也需要时分系统的支持。</li><li>睡眠唤醒
进程可以主动睡眠释放 CPU,这需要时分系统在其唤醒后重新调度其 CPU 时间。</li><li>同步机制
Linux 提供多种同步机制,这都需要时分系统来实现进程之间的协调与调度。</li></ol></blockquote><p>时分系统是 Linux 实现多道程序、并发执行、实时响应、时间管理等功能的基础。它使 Linux 能够充分利用 CPU 资源,实现高效率与公平的调度。时分系统的思想贯穿 Linux 内核的方方面面,是理解 Linux 调度与实现并发执行的重要概念。</p><h2 id=聊一下linux的时序>聊一下Linux的时序
<a class=header-anchor href=#%e8%81%8a%e4%b8%80%e4%b8%8blinux%e7%9a%84%e6%97%b6%e5%ba%8f></a></h2><p>接下来我们需要提前了解几个概念：</p><h3 id=some-words>Some Words
<a class=header-anchor href=#some-words></a></h3><h4 id=jiffies>Jiffies
<a class=header-anchor href=#jiffies></a></h4><p>有更多兴趣的可以看看《
<a href=https://q9jvw0u5f5.feishu.cn/wiki/wikcnTpEK9eLIO6F5w1hhvjHgeh title=内核时钟问题 rel="noopener external nofollow noreferrer" target=_blank class=exturl>内核时钟问题
<i class="fa fa-external-link-alt"></i>
</a>》</p><p>jiffies是一个非常重要的Linux内核变量,它代表了自系统启动以来的时间戳,以时钟中断的个数来表示。它有以下特点:</p><ol><li>jiffies以时钟中断的个数来衡量时间,所以它的精度由时钟中断频率决定。一般的1000HZ时钟中断,jiffies的精度为1ms。</li><li>jiffies是一个无符号的长整型数值,会随着时钟中断不断累加。所以它的取值范围决定了Linux可以持续运行的最大时间。</li><li>jiffies的值在溢出后会重新从0开始累加。所以它只能用于衡量从某个时刻起的较短时间,不能直接用于表示系统的绝对时间。</li><li>内核中的很多时间相关参数都使用jiffies作为单位,如时间片的大小、时钟中断的间隔等。这使得Linux可以根据不同的时钟源进行 Migration。</li><li>jiffies可以用于比较两个时间戳之间的时间差,判断某个事件是否超时等。但在比较绝对时间时要特别注意jiffies的溢出问题。</li><li>可以通过jiffies的变化速度来粗略判断Linux内核的负载情况。jiffies变化越快,说明时钟中断越频繁,系统负载可能越重。</li><li>在用户空间,可以通过/proc/uptime文件来获取以秒为单位的系统启动时间与当前jiffies值。这可以用于计算系统的绝对时间等。</li></ol><p>所以,jiffies作为Linux内核中的时间戳变量,具有以下重要意义:</p><ol><li>它使Linux的时间单位由具体的时钟源独立,可以根据不同的时钟进行Migration。</li><li>它用于衡量较短的时间区间,判断超时等,但由于可能的溢出,不适用于表示绝对时间。</li><li>它的变化情况可以反映系统的负载情况,用于粗略判断系统性能。</li><li>通过它可以在内核与用户空间translating不同时间单位,如HZ与秒。</li><li>许多内核定时与时序相关的参数都基于jiffies,所以它是Linux时间管理的基础。</li></ol><p>理解jiffies的含义与作用,可以帮助我们更深入理解Linux内核的时间管理机制。它使Linux的时间单位由硬件时钟源独立,是Linux灵活管理时间的基石。</p><h4 id=cpu时间片>CPU时间片
<a class=header-anchor href=#cpu%e6%97%b6%e9%97%b4%e7%89%87></a></h4><p>CPU时间片是操作系统为实现CPU调度而引入的一种机制。它的主要作用是:</p><ol><li>实现CPU资源的公平共享,通过定期中断当前运行进程,让其他进程也有机会运行,避免优先级高的进程独占CPU。</li><li>避免任何一个进程长时间占用CPU,影响其他进程运行与系统的响应速度。</li><li>为CPU调度器提供时机,定期重新评估进程优先级,选择最适宜运行的进程。</li></ol><p>CPU时间片的原理是:</p><ol><li>操作系统根据时钟中断来对CPU的使用进行隔离与限制。当时间片用完时,会暂停当前运行进程,让CPU调度器选择其他进程运行。</li><li>CFS调度器会根据进程的优先级与其他因素为每个进程分配一个时间片,决定其可以运行的时间。</li><li>进程运行时会消耗其时间片,当时间片用完时会被调度出CPU,腾出时间让其他进程运行。</li><li>进程如果在时间片用完前主动放弃CPU(如IO阻塞),其剩余时间片会被保存,在下次获得CPU时继续使用。</li><li>实时进程可以设置固定的时间片,不受CFS调度器影响,以保证其实时响应需求。</li></ol><p>CPU时间片的大小(时钟中断频率)直接影响着调度的频率与公平性。时间片较小,可以增强公平性与响应速度;但也会增加上下文切换开销。时间片的设置需要平衡公平性与效率。</p><p>在Linux内核中,时钟中断频率为1000HZ,时间片默认为1ms。CFS调度器会根据各进程的漂移值动态调整时间片大小,但不会超过默认最大时间片。这可以很好地平衡调度的公平性与开销。</p><h4 id=cpu队列>CPU队列
<a class=header-anchor href=#cpu%e9%98%9f%e5%88%97></a></h4><p>CPU队列是Linux内核用于管理可运行进程( TASK_RUNNING状态)的一种数据结构。它主要有以下作用:</p><ol><li>临时保存可运行但未被当前CPU选择的进程,等待下次调度。</li><li>根据进程的优先级、调度策略对进程进行排序,为CPU调度提供候选进程。</li><li>实现公平的CPU资源共享,防止优先级高的进程独占CPU。</li></ol><p>Linux内核的CPU队列主要有以下几种:</p><ol><li>运行队列(runqueue):每CPU一个,保存正在该CPU上运行或准备运行的进程。CFS调度器直接从该队列中选择进程调度运行。</li><li>备选队列(backup queue):全局只有一个,保存从其他CPU上被推出的进程,等待重新调度。主要防止优先级高的进程被starvation。</li><li>过期队列(expired queue):全局只有一个,保存时间片用完但优先级较高未立即调度出CPU的进程。等待下次调度考虑。</li><li>唤醒队列(wakeup queue):全局只有一个,保存从睡眠状态被唤醒的进程,等待下次调度。</li></ol><p>这些CPU队列间的数据流转如下:</p><p>新创建的进程 &ndash;> 唤醒队列 &ndash;> 备选队列 &ndash;> 过期队列 &ndash;> 运行队列</p><p>处于RUNNING状态的进程会被添加到各自CPU的运行队列等待调度运行;如果被调度出CPU会进入备选队列或过期队列;从睡眠唤醒会进入唤醒队列。这些队列围绕 RUNNABLE和RUNNING两种状态对进程进行管理与排序。</p><p>CFS调度器会从运行队列和备选队列选择进程进行调度。过期队列和唤醒队列的进程也会在适当情况下被提前调度运行。这些队列的使用与进程之间的流转,确保了每个CPU资源可以充分并公平地被需要使用的进程利用,实现了Linux的时间共享调度策略。</p><h3 id=so>SO？
<a class=header-anchor href=#so></a></h3><p>在Linux内核中,CPU时间片用于实现CPU调度中的时间共享,它的处理逻辑如下:</p><ol><li>内核定期根据时钟中断来隔离进程或线程与CPU的执行,这就是CPU上下文切换,目的是为了重新选择其他进程或线程运行。</li><li>时钟中断频率决定了时间片的大小,时钟越快,时间片越小,CPU调度越频繁。早期通过PIT提供100HZ(10ms)的时钟中断,现代内核主要使用HPET提供的1000HZ(1ms)中断。</li><li>时间片的分配由CFS调度器决定,原则上每个进程获得的时间片大小应该与它的优先级和漂移值成正比。CFS会实时计算每个进程的vruntime来判断其获得的时间片。</li><li>内核通过托管进程上下文来记录进程运行的时间片使用情况,包括:时间片大小、已经使用的时间片、是否在运行等,这些信息保存在task_struct结构体中。</li><li>当进程获得CPU执行资源时,会从time_slice中减去使用的时间片,如果time_slice用完,则意味着时间片用完,应进行调度并重新选择其他进程运行。</li><li>如果在时间片用完之前,进程主动放弃CPU(如睡眠、IO等),则剩余的时间片会保留,在下次获得CPU执行时继续使用。但切换超过一定次数后,原有时间片会作废,从新分配。</li><li>内核会根据时钟中断周期不断检查正在运行的进程时间片使用情况,一旦时间片用完,就会将该进程置为可调度状态,并选择其他进程运行。</li><li>针对实时进程,内核可以设置静态的时间片,让其不受CFS调度器的管理,获得定期的CPU执行时间。这可以满足实时进程的需求。</li></ol><p>所以,在Linux内核的CPU调度中,时间片起着非常重要的作用。它可以实现公平的CPU共享,满足不同进程的调度需求。内核通过<strong>时钟中断</strong>、CFS调度器和进程上下文来实现<strong>时间片</strong>的分配、管理与使用检查,以控制每个CPU运算周期中各个进程获得的执行时间,实现CPU资源的分配与调度。</p><h3 id=那时钟中断频率和时间片有什么关系和区别>那时钟中断频率和时间片有什么关系和区别？
<a class=header-anchor href=#%e9%82%a3%e6%97%b6%e9%92%9f%e4%b8%ad%e6%96%ad%e9%a2%91%e7%8e%87%e5%92%8c%e6%97%b6%e9%97%b4%e7%89%87%e6%9c%89%e4%bb%80%e4%b9%88%e5%85%b3%e7%b3%bb%e5%92%8c%e5%8c%ba%e5%88%ab></a></h3><p>时钟中断频率和时间片是两个相关但不同的概念:</p><ol><li>时钟中断频率决定了时钟中断的次数,即CPU上下文切换的频率。时钟中断越频繁,上下文切换越频繁,时间片就越小。</li><li>时间片决定了每个进程在获得CPU时间后可以占用CPU的最大时间长度。时间片的大小由操作系统根据时钟中断频率与调度策略来确定。</li><li>时钟中断是一种事件,用于通知操作系统隔离当前运行的进程,选择其他进程运行。它的频率反映了这个隔离动作的次数。</li><li>时间片是一种资源分配机制,它决定了每个进程获得CPU时间后可以独占使用CPU的时间长短。</li></ol><p>它们的关系是:</p><ol><li>时钟中断频率越高,时间片就越小。比如100HZ对应10ms时间片,1000HZ对应1ms时间片。</li><li>时间片的大小限制了一个进程可以独占CPU运行的最长时间。时钟中断用于在时间片用完时强制隔离当前进程,让其他进程运行。</li><li>时钟中断必须大于等于时间片大小。如果时钟中断频率为10HZ,但时间片为5ms,将是不合理的,这会导致定时器在时间片内无法生效。</li><li>较小的时间片可以增强调度的公平性与响应速度,但会增加上下文切换开销。时钟中断频率与时间片的设置需要在这两个方面进行权衡。</li></ol><p>所以,总结来说:</p><ul><li>时钟中断频率决定了CPU上下文切换的频率,影响操作系统的调度频率。</li><li>时间片决定了每个进程CPU占用时间的大小,影响调度的公平性与进程等待时间。</li><li>时钟中断频率越高,时间片越小;但也增加上下文切换开销。</li><li>它们需要根据系统需求进行权衡,设置合适的参数。</li></ul><p>正确理解时钟中断与时间片的关系与区别,对学习操作系统的调度机制非常重要。时钟中断提供了调度的动力,时间片实现了调度的公平策略。两者相互配合,才能完成操作系统高效而合理的CPU调度。
所以,总的来说,时钟中断频率决定了<code>调度的节奏</code>,时间片决定了<code>每个进程的时间分配</code>。它们共同构成操作系统CPU调度的基本机制。</p><h3 id=补习了这些概念有啥用>补习了这些概念有啥用？
<a class=header-anchor href=#%e8%a1%a5%e4%b9%a0%e4%ba%86%e8%bf%99%e4%ba%9b%e6%a6%82%e5%bf%b5%e6%9c%89%e5%95%a5%e7%94%a8></a></h3><p>我们开发出来的程序和产品跑在现代操作系统上，也包括Kubernetes等，知名的大佬都在研究时间的处理问题，有兴趣可以点击下面的链接看看：
<a href=https://github.com/kubernetes/kubernetes/pull/111520 title=https://github.com/kubernetes/kubernetes/pull/111520 rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://github.com/kubernetes/kubernetes/pull/111520
<i class="fa fa-external-link-alt"></i>
</a><a href=https://github.com/zalando-incubator/kubernetes-on-aws/pull/923 title=https://github.com/zalando-incubator/kubernetes-on-aws/pull/923 rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://github.com/zalando-incubator/kubernetes-on-aws/pull/923
<i class="fa fa-external-link-alt"></i>
</a>甚至包括知名理论《
<a href=https://zhuanlan.zhihu.com/p/99131787 title=排队论 rel="noopener external nofollow noreferrer" target=_blank class=exturl>排队论
<i class="fa fa-external-link-alt"></i>
</a>》</p><h2 id=排队论>排队论
<a class=header-anchor href=#%e6%8e%92%e9%98%9f%e8%ae%ba></a></h2><p>排队论是运筹学的一个重要分支,主要研究的是排队系统的性能分析与优化。它通过建立数学模型来分析客户的到达模式、服务模式、排队discipline等因素对系统性能的影响,帮助我们理解和优化复杂的排队系统。
排队论可以很好地用来描述和分析CPU的时序问题。我们可以将CPU看作一个服务器,任务或进程作为客户,建立数学模型来分析不同调度策略对CPU性能的影响。
具体来说,我们可以这样建模:</p><ol><li>客户:CPU上的任务或进程,它们会不断地到达与等待CPU服务。这些任务的到达模式可以看作是随机的。</li><li>服务器:CPU内核,它按照一定的规则为任务提供计算服务。CPU的服务时间也可以看作是一个随机变量。</li><li>排队区:就绪队列(ready queue),保存已就绪等待运行的任务。不同的调度规则对应不同的排队规则。</li><li>服务机制:CPU调度器,它从就绪队列中选择任务并调度到CPU上运行。不同的调度算法对应不同的服务机制。</li></ol><p>基于该模型,我们可以分析不同调度策略对CPU性能的影响:</p><ol><li>FCFS:就绪队列相当于FIFO,会对短任务不公平,长任务的响应会很长。</li><li>SJF:可以优化平均响应时间,但可能导致长任务的starvation。</li><li>轮转法:间接限制每个任务的CPU时间,可以提高公平性但可能会降低CPU利用率。</li><li>优先级:为高优先级任务提供更快服务,可以提高效率,但也可能出现priority inversion等问题。</li><li>反馈队列:根据任务的CPU使用情况动态调整其优先级,在公平性与效率间达到平衡。</li><li>增加CPU数量:可以提高系统吞吐量,但也增加硬件成本与管理难度。</li><li>亲和性:将任务与特定CPU绑定,可以提高缓存利用率与性能,需要权衡任务移动开销。</li></ol><p>所以,我们可以看到,CPU调度中的许多问题如公平性、吞吐量、响应性、优先级等,都可以借助排队论的模型与分析方法来研究。通过调整服务模式、排队规则与 CPU 数量等参数,可以实现不同的调度策略,优化 CPU 性能。</p><p>排队论为我们理解和分析复杂的 CPU 调度机制提供了非常有用的工具和思路。它可以将调度问题数学化与模型化,帮助我们从更高的角度去思考与优化问题。所以,排队论是我们研究操作系统与学习 CPU 调度机制的重要基础理论之一</p><h2 id=提外话也聊一下>提外话也聊一下
<a class=header-anchor href=#%e6%8f%90%e5%a4%96%e8%af%9d%e4%b9%9f%e8%81%8a%e4%b8%80%e4%b8%8b></a></h2><h3 id=观测cpu截流>观测CPU截流
<a class=header-anchor href=#%e8%a7%82%e6%b5%8bcpu%e6%88%aa%e6%b5%81></a></h3><p>CPU截流的原理是控制进程对CPU的访问,以保证系统的稳定性和公平性。它的主要思想是:当CPU超过某个利用阈值时,限制进程对CPU的访问,从而防止CPU过度占用。</p><h4 id=cpu截流通常用于以下场景>CPU截流通常用于以下场景:
<a class=header-anchor href=#cpu%e6%88%aa%e6%b5%81%e9%80%9a%e5%b8%b8%e7%94%a8%e4%ba%8e%e4%bb%a5%e4%b8%8b%e5%9c%ba%e6%99%af></a></h4><ol><li>防止CPU过载。当系统CPU利用率过高时,通过CPU截流可以限制个别进程的CPU使用,避免CPU过载导致系统崩溃或响应缓慢。</li><li>保证服务质量。可以通过CPU截流来保证关键业务进程获取足够的CPU资源,避免被其他进程挤占。这样可以为关键业务提供稳定的服务质量。</li><li>防止进程CPU starvation。通过CPU截流可以避免个别进程长期无法获取CPU时间片的情况,保证每一个进程都有机会运行。</li></ol><h4 id=cpu截流通常有两种主要方式>CPU截流通常有两种主要方式:
<a class=header-anchor href=#cpu%e6%88%aa%e6%b5%81%e9%80%9a%e5%b8%b8%e6%9c%89%e4%b8%a4%e7%a7%8d%e4%b8%bb%e8%a6%81%e6%96%b9%e5%bc%8f></a></h4><ol><li>时间片截流。限制进程在每个时钟中断周期内可以使用的CPU时间片。例如可以限制为原来的80%。</li><li>IO速率限制。限制进程的IO吞吐速率,间接限制其CPU使用。因为CPU使用通常伴随着IO操作,限制IO可以减少CPU占用。</li></ol><p>在Linux系统中,可以使用ulimit、cpulimit等工具来设置进程的CPU截流。另外,cgroups也提供了CPU限制功能,可以更精细地控制容器/进程的CPU使用。</p><p>CPU截流是一个非常有用的技术,它可以帮助系统管理员更好地管理CPU资源,提供更加稳定可靠的服务。但如果使用不当,也会影响系统和业务的性能,所以需要慎重设置各个进程的CPU限制。</p><h4 id=cpu截流的计算逻辑主要涉及两个方面>CPU截流的计算逻辑主要涉及两个方面:
<a class=header-anchor href=#cpu%e6%88%aa%e6%b5%81%e7%9a%84%e8%ae%a1%e7%ae%97%e9%80%bb%e8%be%91%e4%b8%bb%e8%a6%81%e6%b6%89%e5%8f%8a%e4%b8%a4%e4%b8%aa%e6%96%b9%e9%9d%a2></a></h4><ol><li><p>CPU利用率计算。需要实时计算系统和各个进程的CPU利用率,作为CPU截流的判断标准。</p><p>CPU利用率的计算公式为:CPU使用时间/测量间隔时间。其中,CPU使用时间可以从/proc/stat中获取,测量间隔时间一般选取1秒。</p><ul><li>系统CPU利用率 = (user + nice + system + idle) / 总时间</li><li>进程CPU利用率 = 进程使用CPU时间 / 总时间</li></ul></li><li><p>CPU截流判断与执行。需要根据CPU利用率判断是否需要执行CPU截流,如果需要则计算每个进程的CPU限制并执行限制。</p><p>判断逻辑可以为:</p><ul><li>如果系统CPU利用率 > 阈值(例如80%)则触发系统级CPU截流</li><li>如果关键进程CPU利用率 &lt; 最小阈值(例如50%)则触发针对该进程的CPU截流</li><li>如果普通进程CPU利用率 > 最大阈值(例如20%)则触发针对该进程的CPU截流</li></ul><p>CPU限制的计算可以基于进程原有的CPU份额来计算,例如:</p><ul><li>系统级别:每个进程CPU限制 = 进程原有CPU份额 * 系统阈值(例如80%)</li><li>进程级别:该进程CPU限制 = 进程原有CPU份额 * 进程阈值(例如50%或20%)</li><li>手动设置某些关键进程的CPU限制,其余进程按比例分配</li></ul></li></ol><h2 id=prometheus和cpu截流的小故事>Prometheus和CPU截流的小故事：
<a class=header-anchor href=#prometheus%e5%92%8ccpu%e6%88%aa%e6%b5%81%e7%9a%84%e5%b0%8f%e6%95%85%e4%ba%8b></a></h2><h3 id=一般主机场景>一般主机场景
<a class=header-anchor href=#%e4%b8%80%e8%88%ac%e4%b8%bb%e6%9c%ba%e5%9c%ba%e6%99%af></a></h3><p>Prometheus可以很方便地实现CPU截流监控与预警。主要可以通过以下几个方面:</p><ol><li><p>CPU利用率指标:</p><ul><li>计算系统总体CPU利用率:rate(node_cpu_seconds_total{mode=&ldquo;system&rdquo;}[1m]) / 60</li><li>计算每个进程的CPU利用率:rate(process_cpu_seconds_total{name=&ldquo;过程名&rdquo;}[1m]) / 60</li></ul></li><li><p>根据CPU利用率判断是否超过阈值,如果超过则触发CPU截流或预警:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-Bash data-lang=Bash><span style=display:flex><span>alert: CPUUtilizationTooHigh 
</span></span><span style=display:flex><span>  expr: rate<span style=color:#f92672>(</span>node_cpu_seconds_total<span style=color:#f92672>{</span>mode<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;system&#34;</span><span style=color:#f92672>}[</span>1m<span style=color:#f92672>])</span> / <span style=color:#ae81ff>60</span> &gt; 0.8 
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-Bash data-lang=Bash><span style=display:flex><span>alert: ProcessCPUOveruse
</span></span><span style=display:flex><span>  expr: rate<span style=color:#f92672>(</span>process_cpu_seconds_total<span style=color:#f92672>{</span>name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;过程名&#34;</span><span style=color:#f92672>}[</span>1m<span style=color:#f92672>])</span> / <span style=color:#ae81ff>60</span> &gt; 0.5
</span></span></code></pre></td></tr></table></div></div></li><li><p>如果触发CPU截流,则需要计算每个进程的CPU限制并设置:</p><p>进程CPU限制 = 进程原有CPU使用量 * (1 - 系统超出阈值的cpu使用比例)</p><p>举例:</p><ul><li>系统CPU利用率阈值:80%</li><li>当前系统CPU利用率:90%</li><li>某进程原有CPU使用量:20%</li></ul><p>则:进程CPU限制 = 20% * (1 - (90% - 80%) / 90%) = 10%</p><p>也就是该进程的CPU利用率限制会从20%降低到10%,实现对其CPU使用量的限制,达到CPU截流的目的。</p></li><li><p>根据CPU限制值,调用cgroup或其他机制设置进程的CPU限额:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-Bash data-lang=Bash><span style=display:flex><span>cgroup_cpu_limit<span style=color:#f92672>{</span>process_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;进程名&#34;</span>,cpu_limit<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;10%&#34;</span><span style=color:#f92672>}</span>
</span></span></code></pre></td></tr></table></div></div><p>此时Prometheus通过步骤1计算cpu利用率,步骤2判断是否超阈值需要CPU截流,步骤3计算每个进程的CPU限制,步骤4设置cgroup对进程的CPU限额来完成整个CPU截流的 workflow。</p></li></ol><h3 id=kubernetes集群>Kubernetes集群
<a class=header-anchor href=#kubernetes%e9%9b%86%e7%be%a4></a></h3><p>在Kubernetes中,可以通过Prometheus监控Pod的CPU利用率并进行CPU截流。主要步骤如下:</p><ol><li><p>监控Pod的CPU利用率指标:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-Bash data-lang=Bash><span style=display:flex><span>rate<span style=color:#f92672>(</span>container_cpu_usage_seconds_total<span style=color:#f92672>{</span>pod<span style=color:#f92672>=</span>~<span style=color:#e6db74>&#34;pod_name&#34;</span>, container<span style=color:#f92672>=</span>~<span style=color:#e6db74>&#34;container_name&#34;</span><span style=color:#f92672>}[</span>1m<span style=color:#f92672>])</span> 
</span></span></code></pre></td></tr></table></div></div></li><li><p>设置CPU利用率阈值,超过阈值触发报警(表示需要对该Pod进行CPU截流):</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-Bash data-lang=Bash><span style=display:flex><span>alert: PodCPUOveruse 
</span></span><span style=display:flex><span>  expr: rate<span style=color:#f92672>(</span>container_cpu_usage_seconds_total<span style=color:#f92672>{</span>pod<span style=color:#f92672>=</span>~<span style=color:#e6db74>&#34;pod_name&#34;</span>, container<span style=color:#f92672>=</span>~<span style=color:#e6db74>&#34;container_name&#34;</span><span style=color:#f92672>}[</span>1m<span style=color:#f92672>])</span> &gt; 0.8
</span></span></code></pre></td></tr></table></div></div></li><li><p>计算Pod的CPU限制值:</p><p>Pod CPU限制 = 总CPU限额 * (1 - 超出阈值的CPU使用比例)</p><p>例如,Pod总CPU限额为2个CPU,当前CPU利用率为90%,阈值为80%。则:</p><p>Pod CPU限制 = 2 * (1 - (90% - 80%) / 90%) = 1 个CPU</p></li><li><p>设置Pod的CPU限额,有两种主要方式:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-Bash data-lang=Bash><span style=display:flex><span>kubectl patch pod pod-name -p <span style=color:#e6db74>&#39;{&#34;spec&#34;:{&#34;containers&#34;:[{&#34;name&#34;:&#34;container-name&#34;,&#34;resources&#34;:{&#34;limits&#34;:{&#34;cpu&#34;: &#34;1&#34;}}}]} }&#39;</span>
</span></span></code></pre></td></tr></table></div></div></li></ol></div><footer class=post-footer><div class=post-tags><a href=/tags/linux>Linux</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=reward-container><div><i class="fa-solid fa-mug-hot"></i>请我喝杯咖啡吧 ヾ(^▽^*)))</div><button>
赞赏</button><div class=post-reward><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/imgs/ali-pay.png alt="蓝宝石的傻话 - 支付宝">
<span>支付宝</span></div><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/imgs/wechat-pay.png alt="蓝宝石的傻话 - 微信">
<span>微信</span></div></div></div><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
闲聊一下CPU时序和现代操作系统二三事</li><li class=post-copyright-author><strong>本文作者： </strong>蓝宝石的傻话</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/posts/opentelemetry/talk-about-cpu-timer/ title=闲聊一下CPU时序和现代操作系统二三事>/posts/opentelemetry/talk-about-cpu-timer/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=/atom.xml><span class=icon><i class="fa fa-rss"></i>
</span><span class=label>RSS</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/posts/ebpf/pixie-try/ rel=next title=eBPF系列之：Pixie浅剖析><i class="fa fa-chevron-left"></i> eBPF系列之：Pixie浅剖析</a></div><div class="post-nav-prev post-nav-item"><a href=/posts/opentelemetry/prometheus-evolution-history-three/ rel=prev title=监控系统企业架构演进史-拨测监控>监控系统企业架构演进史-拨测监控
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2010 - 2024
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>蓝宝石的傻话</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.131.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>粤ICP备2023145803号</a>
<img src=/imgs/gongan.png alt=粤公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011102001194" target=_blank>粤公网安备 44011102001194 号</a></div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":true,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.5.3","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.b0c78e5a4df586ee46d02716ffa91a4a322e56763e04e91eb2ba052c9469ed02.js defer></script></body></html>